'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var sqlite3 = require('sqlite3');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var sqlite3__default = /*#__PURE__*/_interopDefaultLegacy(sqlite3);

class SqliteConnection {
  constructor(database, sessionStorageIdentifier) {
    this.sessionStorageIdentifier = void 0;
    this.ready = void 0;
    this.db = void 0;
    this.sessionStorageIdentifier = sessionStorageIdentifier;
    this.ready = this.init(database);
  }
  async query(query, params = []) {
    await this.ready;
    return new Promise((resolve, reject) => {
      this.db.all(query, params, (err, result) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(result);
      });
    });
  }
  async executeRawQuery(query) {
    await this.ready;
    return new Promise((resolve, reject) => {
      this.db.exec(query, err => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
  async hasTable(tablename) {
    await this.ready;
    const query = `
    SELECT name FROM sqlite_schema
    WHERE
      type = 'table' AND
      name = ${this.getArgumentPlaceholder()};
    `;
    const rows = await this.query(query, [tablename]);
    return rows.length === 1;
  }
  getArgumentPlaceholder(_) {
    return `?`;
  }
  async connect() {
    await this.ready;

    // Nothing to do here
    return Promise.resolve();
  }
  async disconnect() {
    await this.ready;

    // Nothing to do here
    return Promise.resolve();
  }
  async init(database) {
    this.db = typeof database === 'string' ? new sqlite3__default["default"].Database(database) : database;
  }
}

exports.SqliteConnection = SqliteConnection;
