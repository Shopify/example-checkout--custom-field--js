{"version":3,"file":"node-package-manager.js","sourceRoot":"","sources":["../../../src/public/node/node-package-manager.ts"],"names":[],"mappings":"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","sourcesContent":["import {AbortError, BugError} from './error.js'\nimport {AbortController, AbortSignal} from './abort.js'\nimport {exec} from './system.js'\nimport {fileExists, readFile, writeFile, findPathUp, glob} from './fs.js'\nimport {dirname, joinPath} from './path.js'\nimport {outputToken, outputContent, outputDebug} from '../../public/node/output.js'\nimport {Version} from '../../private/node/semver.js'\nimport latestVersion from 'latest-version'\nimport type {Writable} from 'stream'\nimport type {ExecOptions} from './system.js'\n\n/** The name of the Yarn lock file */\nexport const yarnLockfile = 'yarn.lock'\n\n/** The name of the npm lock file */\nexport const npmLockfile = 'package-lock.json'\n\n/** The name of the pnpm lock file */\nexport const pnpmLockfile = 'pnpm-lock.yaml'\n\n/** The name of the pnpm workspace file */\nexport const pnpmWorkspaceFile = 'pnpm-workspace.yaml'\n\n/** An array containing the lockfiles from all the package managers */\nexport const lockfiles: Lockfile[] = [yarnLockfile, pnpmLockfile, npmLockfile]\nexport type Lockfile = 'yarn.lock' | 'package-lock.json' | 'pnpm-lock.yaml'\n\n/**\n * A union type that represents the type of dependencies in the package.json\n * - dev: devDependencies\n * - prod: dependencies\n * - peer: peerDependencies\n */\nexport type DependencyType = 'dev' | 'prod' | 'peer'\n\n/**\n * A union that represents the package managers available.\n */\nexport const packageManager = ['yarn', 'npm', 'pnpm'] as const\nexport type PackageManager = (typeof packageManager)[number]\n\n/**\n * Returns an abort error that's thrown when a directory that's expected to have\n * a package.json doesn't have it.\n * @param directory - The path to the directory that should contain a package.json\n * @returns An abort error.\n */\nexport const PackageJsonNotFoundError = (directory: string): AbortError => {\n  return new AbortError(`The directory ${directory} doesn't have a package.json.`)\n}\n\n/**\n * Returns a bug error that's thrown when the lookup of the package.json traversing the directory\n * hierarchy up can't find a package.json\n * @param directory - The directory from which the traverse has been done\n * @returns An abort error.\n */\nexport const FindUpAndReadPackageJsonNotFoundError = (directory: string): BugError => {\n  return new BugError(\n    outputContent`Couldn't find a a package.json traversing directories from ${outputToken.path(directory)}`,\n  )\n}\n\n/**\n * Returns the dependency manager used to run the create workflow.\n * @param env - The environment variables of the process in which the CLI runs.\n * @returns The dependency manager\n */\nexport function packageManagerUsedForCreating(env = process.env): PackageManager | 'unknown' {\n  if (env.npm_config_user_agent?.includes('yarn')) {\n    return 'yarn'\n  } else if (env.npm_config_user_agent?.includes('pnpm')) {\n    return 'pnpm'\n  } else if (env.npm_config_user_agent?.includes('npm')) {\n    return 'npm'\n  }\n  return 'unknown'\n}\n\n/**\n * Returns the dependency manager used by an existing project.\n * @param fromDirectory - The starting directory\n * @returns The dependency manager\n */\nexport async function getPackageManager(fromDirectory: string): Promise<PackageManager> {\n  const packageJson = await findPathUp('package.json', {cwd: fromDirectory, type: 'file'})\n  if (!packageJson) {\n    throw FindUpAndReadPackageJsonNotFoundError(fromDirectory)\n  }\n  const directory = dirname(packageJson)\n  outputDebug(outputContent`Obtaining the dependency manager in directory ${outputToken.path(directory)}...`)\n  const yarnLockPath = joinPath(directory, yarnLockfile)\n  const pnpmLockPath = joinPath(directory, pnpmLockfile)\n  if (await fileExists(yarnLockPath)) {\n    return 'yarn'\n  } else if (await fileExists(pnpmLockPath)) {\n    return 'pnpm'\n  } else {\n    return 'npm'\n  }\n}\n\ninterface InstallNPMDependenciesRecursivelyOptions {\n  /**\n   * The dependency manager to use to install the dependencies.\n   */\n  packageManager: PackageManager\n  /**\n   * The directory from where we'll find package.json's recursively\n   */\n  directory: string\n\n  /**\n   * Specifies the maximum depth of the glob search.\n   */\n  deep?: number\n}\n\n/**\n * This function traverses down a directory tree to find directories containing a package.json\n * and installs the dependencies if needed. To know if it's needed, it uses the \"check\" command\n * provided by dependency managers.\n * @param options - Options to install dependencies recursively.\n */\nexport async function installNPMDependenciesRecursively(\n  options: InstallNPMDependenciesRecursivelyOptions,\n): Promise<void> {\n  const packageJsons = await glob(joinPath(options.directory, '**/package.json'), {\n    ignore: [joinPath(options.directory, 'node_modules/**/package.json')],\n    cwd: options.directory,\n    onlyFiles: true,\n    deep: options.deep,\n  })\n  const abortController = new AbortController()\n  try {\n    await Promise.all(\n      packageJsons.map(async (packageJsonPath) => {\n        const directory = dirname(packageJsonPath)\n        await installNodeModules({\n          directory,\n          packageManager: options.packageManager,\n          stdout: undefined,\n          stderr: undefined,\n          signal: abortController.signal,\n          args: [],\n        })\n      }),\n    )\n  } catch (error) {\n    abortController.abort()\n    throw error\n  }\n}\n\ninterface InstallNodeModulesOptions {\n  directory: string\n  args: string[]\n  packageManager: PackageManager\n  stdout?: Writable\n  stderr?: Writable\n  signal?: AbortSignal\n}\n\nexport async function installNodeModules(options: InstallNodeModulesOptions): Promise<void> {\n  const execOptions: ExecOptions = {\n    cwd: options.directory,\n    stdin: undefined,\n    stdout: options.stdout,\n    stderr: options.stderr,\n    signal: options.signal,\n  }\n  let args = ['install']\n  if (options.args) {\n    args = args.concat(options.args)\n  }\n  await exec(options.packageManager, args, execOptions)\n}\n\n/**\n * Returns the name of the package configured in its package.json\n * @param packageJsonPath - Path to the package.json file\n * @returns A promise that resolves with the name.\n */\nexport async function getPackageName(packageJsonPath: string): Promise<string | undefined> {\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n  return packageJsonContent.name\n}\n\n/**\n * Returns the list of production and dev dependencies of a package.json\n * @param packageJsonPath - Path to the package.json file\n * @returns A promise that resolves with the list of dependencies.\n */\nexport async function getDependencies(packageJsonPath: string): Promise<{[key: string]: string}> {\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n  const dependencies: {[key: string]: string} = packageJsonContent.dependencies ?? {}\n  const devDependencies: {[key: string]: string} = packageJsonContent.devDependencies ?? {}\n\n  return {...dependencies, ...devDependencies}\n}\n\n/**\n * Returns true if the app uses workspaces, false otherwise.\n * @param packageJsonPath - Path to the package.json file\n * @param pnpmWorkspacePath - Path to the pnpm-workspace.yaml file\n * @returns A promise that resolves with true if the app uses workspaces, false otherwise.\n */\nexport async function usesWorkspaces(appDirectory: string): Promise<boolean> {\n  const packageJsonPath = joinPath(appDirectory, 'package.json')\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n  const pnpmWorkspacePath = joinPath(appDirectory, pnpmWorkspaceFile)\n  return Boolean(packageJsonContent.workspaces) || fileExists(pnpmWorkspacePath)\n}\n\n/**\n * Given an NPM dependency, it checks if there's a more recent version, and if there is, it returns its value.\n * @param dependency - The dependency name (e.g. react)\n * @param currentVersion - The current version.\n * @returns A promise that resolves with a more recent version or undefined if there's no more recent version.\n */\nexport async function checkForNewVersion(dependency: string, currentVersion: string): Promise<string | undefined> {\n  outputDebug(outputContent`Checking if there's a version of ${dependency} newer than ${currentVersion}`)\n  try {\n    const lastVersion = await getLatestNPMPackageVersion(dependency)\n    if (lastVersion && new Version(currentVersion).compare(lastVersion) < 0) {\n      return lastVersion\n    } else {\n      return undefined\n    }\n    // eslint-disable-next-line no-catch-all/no-catch-all\n  } catch (error) {\n    return undefined\n  }\n}\n\n/**\n * An interface that represents a package.json\n */\nexport interface PackageJson {\n  /**\n   * The name attribute of the package.json\n   */\n  name?: string\n\n  /**\n   * The author attribute of the package.json\n   */\n  author?: string\n\n  /**\n   * The version attribute of the package.json\n   */\n  version?: string\n\n  /**\n   * The scripts attribute of the package.json\n   */\n  scripts?: {[key: string]: string}\n\n  /**\n   * The dependencies attribute of the package.json\n   */\n  dependencies?: {[key: string]: string}\n\n  /**\n   * The devDependencies attribute of the package.json\n   */\n  devDependencies?: {[key: string]: string}\n\n  /**\n   * The optional oclif settings attribute of the package.json\n   */\n  oclif?: {\n    plugins?: string[]\n  }\n\n  /**\n   * The workspaces attribute of the package.json\n   */\n  workspaces?: string[]\n\n  /**\n   * The resolutions attribute of the package.json. Only useful when using yarn as package manager\n   */\n  resolutions?: {[key: string]: string}\n\n  /**\n   * The overrides attribute of the package.json. Only useful when using npm o npmn as package managers\n   */\n  overrides?: {[key: string]: string}\n\n  /**\n   *  The prettier attribute of the package.json\n   */\n  prettier?: string\n}\n\n/**\n * Reads and parses a package.json\n * @param packageJsonPath - Path to the package.json\n * @returns An promise that resolves with an in-memory representation\n *    of the package.json or rejects with an error if the file is not found or the content is\n *    not decodable.\n */\nexport async function readAndParsePackageJson(packageJsonPath: string): Promise<PackageJson> {\n  if (!(await fileExists(packageJsonPath))) {\n    throw PackageJsonNotFoundError(dirname(packageJsonPath))\n  }\n  return JSON.parse(await readFile(packageJsonPath))\n}\n\ninterface AddNPMDependenciesIfNeededOptions {\n  /** How dependencies should be added */\n  type: DependencyType\n\n  /** The dependency manager to use to add dependencies */\n  packageManager: PackageManager\n\n  /** The directory that contains the package.json where dependencies will be added */\n  directory: string\n\n  /** Standard output coming from the underlying installation process */\n  stdout?: Writable\n\n  /** Standard error coming from the underlying installation process */\n  stderr?: Writable\n\n  /** Abort signal to stop the process */\n  signal?: AbortSignal\n\n  /** Whether or not to install exact versions of the dependencies */\n  exact?: boolean\n}\n\n/**\n * An interface that represents a dependency name with its version\n */\nexport interface DependencyVersion {\n  /**\n   * The name of the NPM dependency as it's reflected in the package.json:\n   *\n   * @example\n   * In the example below name would be \"react\"\n   * ```\n   * {\n   *   \"react\": \"1.2.3\"\n   * }\n   * ```\n   */\n  name: string\n\n  /**\n   * The version of the NPM dependency as it's reflected in the package.json:\n   *\n   * @example\n   * In the example below version would be \"1.2.3\"\n   * ```\n   * {\n   *   \"react\": \"1.2.3\"\n   * }\n   * ```\n   */\n  version: string | undefined\n}\n\n/**\n * Adds dependencies to a Node project (i.e. a project that has a package.json)\n * @param dependencies - List of dependencies to be added.\n * @param options - Options for adding dependencies.\n */\nexport async function addNPMDependenciesIfNeeded(\n  dependencies: DependencyVersion[],\n  options: AddNPMDependenciesIfNeededOptions,\n): Promise<void> {\n  outputDebug(outputContent`Adding the following dependencies if needed:\n${outputToken.json(dependencies)}\nWith options:\n${outputToken.json(options)}\n  `)\n  const packageJsonPath = joinPath(options.directory, 'package.json')\n  if (!(await fileExists(packageJsonPath))) {\n    throw PackageJsonNotFoundError(options.directory)\n  }\n  const existingDependencies = Object.keys(await getDependencies(packageJsonPath))\n  let dependenciesToAdd = dependencies\n  dependenciesToAdd = dependencies.filter((dep) => {\n    return !existingDependencies.includes(dep.name)\n  })\n  if (dependenciesToAdd.length === 0) {\n    return\n  }\n  await addNPMDependencies(dependenciesToAdd, options)\n}\n\nexport async function addNPMDependencies(\n  dependencies: DependencyVersion[],\n  options: AddNPMDependenciesIfNeededOptions,\n): Promise<void> {\n  let args: string[]\n  const dependenciesWithVersion = dependencies.map((dep) => {\n    return dep.version ? `${dep.name}@${dep.version}` : dep.name\n  })\n  options.stdout?.write(`Installing ${[dependenciesWithVersion].join(' ')} with ${options.packageManager}`)\n  switch (options.packageManager) {\n    case 'npm':\n      // npm isn't too smart when resolving the dependency tree. For example, admin ui extensions include react as\n      // a peer dependency, but npm can't figure out the relationship and fails. Installing dependencies one by one\n      // makes the task easier and npm can then proceed.\n      for (const dep of dependenciesWithVersion) {\n        // eslint-disable-next-line no-await-in-loop\n        await installDependencies(options, argumentsToAddDependenciesWithNPM([dep], options.type, options.exact))\n      }\n      break\n    case 'yarn':\n      await installDependencies(\n        options,\n        argumentsToAddDependenciesWithYarn(dependenciesWithVersion, options.type, options.exact),\n      )\n      break\n    case 'pnpm':\n      await installDependencies(\n        options,\n        argumentsToAddDependenciesWithPNPM(dependenciesWithVersion, options.type, options.exact),\n      )\n      break\n  }\n}\n\nasync function installDependencies(options: AddNPMDependenciesIfNeededOptions, args: string[]) {\n  return exec(options.packageManager, args, {\n    cwd: options.directory,\n    stdout: options.stdout,\n    stderr: options.stderr,\n    signal: options.signal,\n  })\n}\n\nexport async function addNPMDependenciesWithoutVersionIfNeeded(\n  dependencies: string[],\n  options: AddNPMDependenciesIfNeededOptions,\n): Promise<void> {\n  await addNPMDependenciesIfNeeded(\n    dependencies.map((dependency) => {\n      return {name: dependency, version: undefined}\n    }),\n    options,\n  )\n}\n\n/**\n * Returns the arguments to add dependencies using NPM.\n * @param dependencies - The list of dependencies to add\n * @param type - The dependency type.\n * @returns An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithNPM(dependencies: string[], type: DependencyType, exact = false): string[] {\n  let command = ['install']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--save-dev')\n      break\n    case 'peer':\n      command.push('--save-peer')\n      break\n    case 'prod':\n      command.push('--save-prod')\n      break\n  }\n  if (exact) command.push('--save-exact')\n  return command\n}\n\n/**\n * Returns the arguments to add dependencies using Yarn.\n * @param dependencies - The list of dependencies to add\n * @param type - The dependency type.\n * @returns An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithYarn(dependencies: string[], type: DependencyType, exact = false): string[] {\n  let command = ['add']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--dev')\n      break\n    case 'peer':\n      command.push('--peer')\n      break\n    case 'prod':\n      command.push('--prod')\n      break\n  }\n  if (exact) command.push('--exact')\n  return command\n}\n\n/**\n * Returns the arguments to add dependencies using PNPM.\n * @param dependencies - The list of dependencies to add\n * @param type - The dependency type.\n * @returns An array with the arguments.\n */\nfunction argumentsToAddDependenciesWithPNPM(dependencies: string[], type: DependencyType, exact = false): string[] {\n  let command = ['add']\n  command = command.concat(dependencies)\n  switch (type) {\n    case 'dev':\n      command.push('--save-dev')\n      break\n    case 'peer':\n      command.push('--save-peer')\n      break\n    case 'prod':\n      command.push('--save-prod')\n      break\n  }\n  if (exact) command.push('--save-exact')\n  return command\n}\n\n/**\n * Given a directory it traverses the directory up looking for a package.json and if found, it reads it\n * decodes the JSON, and returns its content as a Javascript object.\n * @param options - The directory from which traverse up.\n * @returns If found, the promise resolves with the path to the\n *  package.json and its content. If not found, it throws a FindUpAndReadPackageJsonNotFoundError error.\n */\nexport async function findUpAndReadPackageJson(fromDirectory: string): Promise<{path: string; content: PackageJson}> {\n  const packageJsonPath = await findPathUp('package.json', {cwd: fromDirectory, type: 'file'})\n  if (packageJsonPath) {\n    const packageJson = JSON.parse(await readFile(packageJsonPath))\n    return {path: packageJsonPath, content: packageJson}\n  } else {\n    throw FindUpAndReadPackageJsonNotFoundError(fromDirectory)\n  }\n}\n\nexport async function addResolutionOrOverride(directory: string, dependencies: {[key: string]: string}): Promise<void> {\n  const packageManager = await getPackageManager(directory)\n  const packageJsonPath = joinPath(directory, 'package.json')\n  const packageJsonContent = await readAndParsePackageJson(packageJsonPath)\n\n  if (packageManager === 'yarn') {\n    packageJsonContent.resolutions = packageJsonContent.resolutions\n      ? {...packageJsonContent.resolutions, ...dependencies}\n      : dependencies\n  }\n  if (packageManager === 'npm' || packageManager === 'pnpm') {\n    packageJsonContent.overrides = packageJsonContent.overrides\n      ? {...packageJsonContent.overrides, ...dependencies}\n      : dependencies\n  }\n\n  await writeFile(packageJsonPath, JSON.stringify(packageJsonContent, null, 2))\n}\n\n/**\n * Returns the latest available version of an NPM package.\n * @param name - The name of the NPM package.\n * @returns A promise to get the latest available version of a package.\n */\nasync function getLatestNPMPackageVersion(name: string) {\n  outputDebug(outputContent`Getting the latest version of NPM package: ${outputToken.raw(name)}`)\n  return latestVersion(name)\n}\n\n/**\n * Writes the package.json file to the given directory.\n *\n * @param directory - Directory where the package.json file will be written.\n * @param packageJSON - Package.json file to write.\n */\nexport async function writePackageJSON(directory: string, packageJSON: PackageJson): Promise<void> {\n  outputDebug(outputContent`JSON-encoding and writing content to package.json at ${outputToken.path(directory)}...`)\n  const packagePath = joinPath(directory, 'package.json')\n  await writeFile(packagePath, JSON.stringify(packageJSON, null, 2))\n}\n"]}