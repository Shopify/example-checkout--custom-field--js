{"version":3,"file":"tcp.js","sourceRoot":"","sources":["../../../src/public/node/tcp.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,KAAK,EAAC,MAAM,aAAa,CAAA;AACjC,OAAO,EAAC,UAAU,EAAC,MAAM,YAAY,CAAA;AACrC,OAAO,EAAC,WAAW,EAAE,aAAa,EAAE,WAAW,EAAC,MAAM,6BAA6B,CAAA;AACnF,OAAO,KAAK,IAAI,MAAM,iBAAiB,CAAA;AAEvC;;;;;GAKG;AACH,MAAM,CAAC,KAAK,UAAU,mBAAmB;IACvC,WAAW,CAAC,aAAa,CAAA,0BAA0B,CAAC,CAAA;IACpD,MAAM,UAAU,GAAG,MAAM,YAAY,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAA;IACjE,WAAW,CAAC,aAAa,CAAA,yBAAyB,WAAW,CAAC,GAAG,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,CAAC,CAAA;IACrF,OAAO,UAAU,CAAA;AACnB,CAAC;AAED;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,qBAAqB,CAAC,UAAkB;IAC5D,OAAO,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,KAAK,UAAU,CAAA;AAC1D,CAAC;AAED;;;;;;GAMG;AACH,KAAK,UAAU,YAAY,CAAI,OAAgB,EAAE,QAAQ,GAAG,CAAC,EAAE,iBAAiB,GAAG,CAAC;IAClF,IAAI,UAAU,GAAG,CAAC,CAAA;IAClB,OAAO,IAAI,EAAE;QACX,IAAI;YACF,4CAA4C;YAC5C,OAAO,MAAM,OAAO,EAAE,CAAA;YACtB,8DAA8D;SAC/D;QAAC,OAAO,KAAU,EAAE;YACnB,IAAI,UAAU,EAAE,GAAG,QAAQ,EAAE;gBAC3B,WAAW,CAAC,aAAa,CAAA,0CAA0C,KAAK,CAAC,OAAO,EAAE,CAAC,CAAA;gBACnF,4CAA4C;gBAC5C,MAAM,KAAK,CAAC,iBAAiB,CAAC,CAAA;aAC/B;iBAAM;gBACL,MAAM,IAAI,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;aACpC;SACF;KACF;AACH,CAAC","sourcesContent":["import {sleep} from './system.js'\nimport {AbortError} from './error.js'\nimport {outputDebug, outputContent, outputToken} from '../../public/node/output.js'\nimport * as port from 'get-port-please'\n\n/**\n * Returns an available port in the current environment.\n *\n * @returns A promise that resolves with an availabe port.\n * @example\n */\nexport async function getAvailableTCPPort(): Promise<number> {\n  outputDebug(outputContent`Getting a random port...`)\n  const randomPort = await retryOnError(() => port.getRandomPort())\n  outputDebug(outputContent`Random port obtained: ${outputToken.raw(`${randomPort}`)}`)\n  return randomPort\n}\n\n/**\n * Checks if a port is available.\n *\n * @param portNumber - The port number to check.\n */\nexport async function checkPortAvailability(portNumber: number): Promise<boolean> {\n  return (await port.checkPort(portNumber)) === portNumber\n}\n\n/**\n * Given a function, it runs it and retries in case of failiure up to the provided number of times.\n *\n * @param execute - The function to execute.\n * @param maxTries - The maximum retries.\n * @param waitTimeInSeconds - The time to wait between retries.\n */\nasync function retryOnError<T>(execute: () => T, maxTries = 5, waitTimeInSeconds = 1) {\n  let retryCount = 1\n  while (true) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      return await execute()\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      if (retryCount++ < maxTries) {\n        outputDebug(outputContent`Unknown problem getting a random port: ${error.message}`)\n        // eslint-disable-next-line no-await-in-loop\n        await sleep(waitTimeInSeconds)\n      } else {\n        throw new AbortError(error.message)\n      }\n    }\n  }\n}\n"]}