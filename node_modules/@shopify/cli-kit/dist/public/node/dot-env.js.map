{"version":3,"file":"dot-env.js","sourceRoot":"","sources":["../../../src/public/node/dot-env.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,UAAU,EAAC,MAAM,YAAY,CAAA;AACrC,OAAO,EAAC,UAAU,EAAE,QAAQ,EAAE,SAAS,EAAC,MAAM,SAAS,CAAA;AACvD,OAAO,EAAC,WAAW,EAAE,aAAa,EAAE,WAAW,EAAC,MAAM,6BAA6B,CAAA;AACnF,6DAA6D;AAC7D,aAAa;AACb,OAAO,EAAC,KAAK,EAAE,SAAS,EAAC,MAAM,SAAS,CAAA;AAExC;;;;GAIG;AACH,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,IAAY,EAAc,EAAE;IAC9D,OAAO,IAAI,UAAU,CAAC,2BAA2B,IAAI,kBAAkB,CAAC,CAAA;AAC1E,CAAC,CAAA;AAgBD;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,kBAAkB,CAAC,IAAY;IACnD,WAAW,CAAC,aAAa,CAAA,4BAA4B,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;IAC9E,IAAI,CAAC,CAAC,MAAM,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE;QAC7B,MAAM,mBAAmB,CAAC,IAAI,CAAC,CAAA;KAChC;IACD,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,CAAA;IACpC,OAAO;QACL,IAAI;QACJ,SAAS,EAAE,KAAK,CAAC,OAAO,CAAC;KAC1B,CAAA;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,CAAC,KAAK,UAAU,WAAW,CAAC,IAAgB;IAChD,MAAM,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAA;AACvD,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,YAAY,CAC1B,cAA6B,EAC7B,aAAkD;IAElD,MAAM,WAAW,GAAa,EAAE,CAAA;IAChC,MAAM,KAAK,GAAG,cAAc,KAAK,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;IAEvE,MAAM,kBAAkB,GAAa,EAAE,CAAA;IAEvC,MAAM,MAAM,GAAG,CAAC,GAAW,EAAE,KAAc,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE,CAAA;IAEjE,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAA;QAC/C,IAAI,WAAW,GAAG,IAAI,CAAA;QAEtB,IAAI,KAAK,EAAE;YACT,MAAM,GAAG,GAAG,KAAK,CAAC,CAAC,CAAE,CAAC,IAAI,EAAE,CAAA;YAC5B,MAAM,QAAQ,GAAG,aAAa,CAAC,GAAG,CAAC,CAAA;YACnC,IAAI,QAAQ,EAAE;gBACZ,kBAAkB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;gBAC5B,WAAW,GAAG,MAAM,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAA;aACpC;SACF;QAED,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;KAC9B;IAED,KAAK,MAAM,CAAC,QAAQ,EAAE,YAAY,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;QACpE,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;YAC1C,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAA;SACjD;KACF;IAED,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AAC/B,CAAC","sourcesContent":["import {AbortError} from './error.js'\nimport {fileExists, readFile, writeFile} from './fs.js'\nimport {outputDebug, outputContent, outputToken} from '../../public/node/output.js'\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport {parse, stringify} from 'envfile'\n\n/**\n * Error that's thrown when the .env is not found.\n * @param path - Path to the .env file.\n * @returns An abort error.\n */\nexport const DotEnvNotFoundError = (path: string): AbortError => {\n  return new AbortError(`The environment file at ${path} does not exist.`)\n}\n\n/**\n * This interface represents a .env file.\n */\nexport interface DotEnvFile {\n  /**\n   * Path to the .env file.\n   */\n  path: string\n  /**\n   * Variables of the .env file.\n   */\n  variables: {[name: string]: string}\n}\n\n/**\n * Reads and parses a .env file.\n * @param path - Path to the .env file\n * @returns An in-memory representation of the .env file.\n */\nexport async function readAndParseDotEnv(path: string): Promise<DotEnvFile> {\n  outputDebug(outputContent`Reading the .env file at ${outputToken.path(path)}`)\n  if (!(await fileExists(path))) {\n    throw DotEnvNotFoundError(path)\n  }\n  const content = await readFile(path)\n  return {\n    path,\n    variables: parse(content),\n  }\n}\n\n/**\n * Writes a .env file to disk.\n * @param file - .env file to be written.\n */\nexport async function writeDotEnv(file: DotEnvFile): Promise<void> {\n  await writeFile(file.path, stringify(file.variables))\n}\n\n/**\n * Given an .env file content, generates a new one with new values\n * without removing already existing lines.\n * @param envFileContent - .env file contents.\n * @param updatedValues - object containing new env variables values.\n */\nexport function patchEnvFile(\n  envFileContent: string | null,\n  updatedValues: {[key: string]: string | undefined},\n): string {\n  const outputLines: string[] = []\n  const lines = envFileContent === null ? [] : envFileContent.split('\\n')\n\n  const alreadyPresentKeys: string[] = []\n\n  const toLine = (key: string, value?: string) => `${key}=${value}`\n\n  for (const line of lines) {\n    const match = line.match(/^([^=:#]+?)[=:](.*)/)\n    let lineToWrite = line\n\n    if (match) {\n      const key = match[1]!.trim()\n      const newValue = updatedValues[key]\n      if (newValue) {\n        alreadyPresentKeys.push(key)\n        lineToWrite = toLine(key, newValue)\n      }\n    }\n\n    outputLines.push(lineToWrite)\n  }\n\n  for (const [patchKey, updatedValue] of Object.entries(updatedValues)) {\n    if (!alreadyPresentKeys.includes(patchKey)) {\n      outputLines.push(toLine(patchKey, updatedValue))\n    }\n  }\n\n  return outputLines.join('\\n')\n}\n"]}