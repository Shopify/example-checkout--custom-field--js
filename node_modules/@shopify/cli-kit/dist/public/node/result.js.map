{"version":3,"file":"result.js","sourceRoot":"","sources":["../../../src/public/node/result.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,UAAU,EAAE,UAAU,EAAE,eAAe,EAAC,MAAM,YAAY,CAAA;AAIlE;;;;;GAKG;AACH,MAAM,CAAC,MAAM,EAAE,GAAG,CAAyB,KAAa,EAAsB,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,CAAA;AAE9F;;;;;GAKG;AACH,MAAM,CAAC,MAAM,GAAG,GAAG,CAAmC,GAAW,EAAuB,EAAE,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAA;AAEvG,MAAM,OAAO,EAAE;IACb,YAAqB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;IAAG,CAAC;IAEtC;;;;OAIG;IACH,KAAK;QACH,OAAO,KAAK,CAAA;IACd,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,OAAgC;QACrC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QACnB,OAAO,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IACvB,CAAC;IAED;;OAEG;IACH,UAAU;QACR,OAAO,IAAI,CAAC,KAAK,CAAA;IACnB,CAAC;IAED;;OAEG;IACH,YAAY;QACV,OAAO,IAAI,CAAC,KAAK,CAAA;IACnB,CAAC;IAED;;;;;OAKG;IACH,GAAG,CAAe,MAAuC;QACvD,OAAO,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAA;IAC/B,CAAC;IAED;;;;;OAKG;IACH,QAAQ,CAAe,OAAwC;QAC7D,OAAO,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IACvB,CAAC;CACF;AAED,MAAM,OAAO,GAAG;IACd,oDAAoD;IACpD,YAAqB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;IAAG,CAAC;IAEtC;;;;OAIG;IACH,KAAK;QACH,OAAO,IAAI,CAAA;IACb,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,QAAiC;QACtC,OAAO,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IACxB,CAAC;IAED;;OAEG;IACH,UAAU;QACR,MAAM,IAAI,CAAC,KAAK,CAAA;IAClB,CAAC;IAED;;OAEG;IACH,YAAY;QACV,IAAI,IAAI,CAAC,KAAK,YAAY,UAAU,EAAE;YACpC,MAAM,IAAI,CAAC,KAAK,CAAA;SACjB;aAAM,IAAI,IAAI,CAAC,KAAK,YAAY,eAAe,IAAI,IAAI,CAAC,KAAK,YAAY,KAAK,EAAE;YAC/E,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;YAChD,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAA;YAC9B,MAAM,KAAK,CAAA;SACZ;aAAM;YACL,MAAM,IAAI,UAAU,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,CAAA;SACtC;IACH,CAAC;IAED;;;;;OAKG;IACH,GAAG,CAAe,OAA6C;QAC7D,OAAO,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IACxB,CAAC;IAED;;;;;OAKG;IACH,QAAQ,CAAe,MAAuC;QAC5D,OAAO,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAA;IAChC,CAAC;CACF","sourcesContent":["import {FatalError, AbortError, ExtendableError} from './error.js'\n\nexport type Result<TValue, TError> = Ok<TValue, TError> | Err<TValue, TError>\n\n/**\n * Utility metho to create an `Ok` result from a `value`\n *\n * @param value - `value` used to crete the `Result`\n * @returns an instance of a `Ok` `Result` inferring its type\n */\nexport const ok = <TValue, TError = never>(value: TValue): Ok<TValue, TError> => new Ok(value)\n\n/**\n * Utility method to create an `Error` result from an `error`\n *\n * @param err - `error` used to crete the `Result`\n * @returns an instance of an `Error` `Result` inferring its type\n */\nexport const err = <TValue = never, TError = unknown>(err: TError): Err<TValue, TError> => new Err(err)\n\nexport class Ok<TValue, TError> {\n  constructor(readonly value: TValue) {}\n\n  /**\n   * Check if a `Result` is an `Err` inferring its type. `!isErr()` should be used before accessing the `value`\n   *\n   * @returns `false` as the `Resul` is `OK`\n   */\n  isErr(): this is Err<TValue, TError> {\n    return false\n  }\n\n  /**\n   * Runs the `handler` method an return the same an unaltered copy of the `Result`. It could be used to log an\n   * output when the result is `Ok` without breaking the flow\n   *\n   * @param handler - method to be run when the result is `Ok`\n   * @returns a copy of the same `Result`\n   */\n  doOnOk(handler: (value: TValue) => void): Result<TValue, TError> {\n    handler(this.value)\n    return ok(this.value)\n  }\n\n  /**\n   * A safe mode to throw the `error` of the `Result`\n   */\n  valueOrBug(): TValue {\n    return this.value\n  }\n\n  /**\n   * Throws an abort error if the result doesn't represent a value.\n   */\n  valueOrAbort(): TValue {\n    return this.value\n  }\n\n  /**\n   * Maps the value to another one with a different type. It leaves the `Error` type unaltered\n   *\n   * @param mapper - The mapper method to apply an `OK` value\n   * @returns a new result with the new mapped value\n   */\n  map<TMappedValue>(mapper: (value: TValue) => TMappedValue): Result<TMappedValue, TError> {\n    return ok(mapper(this.value))\n  }\n\n  /**\n   * Maps the error type to another one. It leaves the `Ok` type and value unaltered\n   *\n   * @param _mapper - This mapper method is not used for an `Ok` value\n   * @returns a new result with the new mapped error type and an value\n   */\n  mapError<TMappedError>(_mapper: (error: TError) => TMappedError): Result<TValue, TMappedError> {\n    return ok(this.value)\n  }\n}\n\nexport class Err<TValue, TError> {\n  // eslint-disable-next-line node/handle-callback-err\n  constructor(readonly error: TError) {}\n\n  /**\n   * Check if a `Result` is an `Err` inferring its type. `!isErr()` should be used before accessing the `value`\n   *\n   * @returns `false` as the `Resul` is `OK`\n   */\n  isErr(): this is Err<TValue, TError> {\n    return true\n  }\n\n  /**\n   * Return an unaltered copy of the `Error` without doing anything.\n   *\n   * @param _handler - This handler method is not used for an `Error`\n   * @returns a copy of the same `Error`\n   */\n  doOnOk(_handler: (value: TValue) => void): Result<TValue, TError> {\n    return err(this.error)\n  }\n\n  /**\n   * A safe mode to throw the `error` of the `Result`\n   */\n  valueOrBug(): TValue {\n    throw this.error\n  }\n\n  /**\n   * Throws an abort error if the result doesn't represent a value.\n   */\n  valueOrAbort(): TValue {\n    if (this.error instanceof FatalError) {\n      throw this.error\n    } else if (this.error instanceof ExtendableError || this.error instanceof Error) {\n      const error = new AbortError(this.error.message)\n      error.stack = this.error.stack\n      throw error\n    } else {\n      throw new AbortError(`${this.error}`)\n    }\n  }\n\n  /**\n   * Maps the value type to another one. It leaves the `Error` unaltered\n   *\n   * @param _mapper - This mapper method is not used for an `Error` value\n   * @returns a new result with the new value type and an unaltered error\n   */\n  map<TMappedValue>(_mapper: (valueOrBug: TValue) => TMappedValue): Result<TMappedValue, TError> {\n    return err(this.error)\n  }\n\n  /**\n   * Maps the error to another one with a different type. It leaves the value type unaltered\n   *\n   * @param mapper - The mapper method to apply an `Error` value\n   * @returns a new result with the new mapped error\n   */\n  mapError<TMappedError>(mapper: (error: TError) => TMappedError): Result<TValue, TMappedError> {\n    return err(mapper(this.error))\n  }\n}\n"]}