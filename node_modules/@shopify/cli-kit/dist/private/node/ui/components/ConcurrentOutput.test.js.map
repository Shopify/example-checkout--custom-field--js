{"version":3,"file":"ConcurrentOutput.test.js","sourceRoot":"","sources":["../../../../../src/private/node/ui/components/ConcurrentOutput.test.tsx"],"names":[],"mappings":"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","sourcesContent":["import {ConcurrentOutput} from './ConcurrentOutput.js'\nimport {getLastFrameAfterUnmount, waitForInputsToBeReady} from '../../testing/ui.js'\nimport {AbortController, AbortSignal} from '../../../../public/node/abort.js'\nimport {unstyled} from '../../../../public/node/output.js'\nimport React from 'react'\nimport {describe, expect, test, vi} from 'vitest'\nimport {render} from 'ink-testing-library'\nimport {Writable} from 'stream'\n\ndescribe('ConcurrentOutput', () => {\n  test('renders a stream of concurrent outputs from sub-processes', async () => {\n    // Given\n    let backendPromiseResolve: () => void\n    let frontendPromiseResolve: () => void\n\n    const backendPromise = new Promise<void>(function (resolve, _reject) {\n      backendPromiseResolve = resolve\n    })\n\n    const frontendPromise = new Promise<void>(function (resolve, _reject) {\n      frontendPromiseResolve = resolve\n    })\n\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n\n        backendPromiseResolve()\n      },\n    }\n\n    const frontendProcess = {\n      prefix: 'frontend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        await backendPromise\n\n        stdout.write('first frontend message')\n        stdout.write('second frontend message')\n        stdout.write('third frontend message')\n\n        frontendPromiseResolve()\n      },\n    }\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[backendProcess, frontendProcess]}\n        abortController={new AbortController()}\n        footer={{\n          shortcuts: [\n            {\n              key: 'p',\n              action: 'open your browser',\n            },\n            {\n              key: 'q',\n              action: 'quit',\n            },\n          ],\n          subTitle: `Preview URL: https://shopify.com`,\n        }}\n      />,\n    )\n\n    // wait for all output to be rendered\n    await frontendPromise\n\n    // Then\n    expect(unstyled(getLastFrameAfterUnmount(renderInstance)!.replace(/\\d/g, '0'))).toMatchInlineSnapshot(`\n      \"0000-00-00 00:00:00 │ backend  │ first backend message\n      0000-00-00 00:00:00 │ backend  │ second backend message\n      0000-00-00 00:00:00 │ backend  │ third backend message\n      0000-00-00 00:00:00 │ frontend │ first frontend message\n      0000-00-00 00:00:00 │ frontend │ second frontend message\n      0000-00-00 00:00:00 │ frontend │ third frontend message\n\n      › Press p │ open your browser\n      › Press q │ quit\n\n      Preview URL: https://shopify.com\n      \"\n    `)\n  })\n\n  test('accepts a onInput function that fires when a key is pressed', async () => {\n    const neverEndingPromise = new Promise<void>(function (_resolve, _reject) {})\n\n    const neverEndingProcess = {\n      prefix: 'never-ending-process',\n      action: async () => {\n        await neverEndingPromise\n      },\n    }\n\n    const onInput = vi.fn()\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[neverEndingProcess]}\n        abortController={new AbortController()}\n        onInput={(input, key) => onInput(input, key)}\n      />,\n    )\n\n    await waitForInputsToBeReady()\n    expect(onInput).toHaveBeenCalledTimes(0)\n\n    renderInstance.stdin.write('a')\n    expect(onInput).toHaveBeenCalledTimes(1)\n    expect(onInput.mock.calls[0]![0]).toBe('a')\n  })\n})\n"]}