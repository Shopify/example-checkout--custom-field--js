{"version":3,"file":"overloaded-parameters.js","sourceRoot":"","sources":["../../../../src/private/common/ts/overloaded-parameters.ts"],"names":[],"mappings":"","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\ntype OverloadProps<TOverload> = Pick<TOverload, keyof TOverload>\n\n// Prevent infinite recursion by stopping recursion when TPartialOverload\n// has accumulated all of the TOverload signatures.\ntype OverloadUnionRecursive<TOverload, TPartialOverload = unknown> = TOverload extends (\n  ...args: infer TArgs\n) => infer TReturn\n  ? TPartialOverload extends TOverload\n    ? never\n    :\n        | OverloadUnionRecursive<\n            TPartialOverload & TOverload,\n            TPartialOverload & ((...args: TArgs) => TReturn) & OverloadProps<TOverload>\n          >\n        | ((...args: TArgs) => TReturn)\n  : never\n\n// The \"() => never\" signature must be hoisted to the \"front\" of the\n// intersection, for two reasons: a) because recursion stops when it is\n// encountered, and b) it seems to prevent the collapse of subsequent\n// \"compatible\" signatures (eg. \"() => void\" into \"(a?: 1) => void\"),\n// which gives a direct conversion to a union.\ntype OverloadUnion<TOverload extends (...args: any[]) => any> = Exclude<\n  OverloadUnionRecursive<(() => never) & TOverload>,\n  TOverload extends () => never ? never : () => never\n>\n\n// Inferring a union of parameter tuples or return types is now possible.\nexport type OverloadParameters<T extends (...args: any[]) => any> = Parameters<OverloadUnion<T>>\nexport type OverloadReturnType<T extends (...args: any[]) => any> = ReturnType<OverloadUnion<T>>\n"]}