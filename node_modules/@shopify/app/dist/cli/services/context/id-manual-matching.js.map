{"version":3,"file":"id-manual-matching.js","sourceRoot":"","sources":["../../../../src/cli/services/context/id-manual-matching.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,wBAAwB,EAAC,MAAM,cAAc,CAAA;AAUrD;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,OAGC,EACD,aAA4B;IAE5B,MAAM,WAAW,GAA4B,EAAE,CAAA;IAC/C,IAAI,aAAa,GAAG,OAAO,CAAC,MAAM,CAAA;IAClC,IAAI,YAAY,GAAG,OAAO,CAAC,KAAK,CAAA;IAEhC,KAAK,MAAM,YAAY,IAAI,OAAO,CAAC,KAAK,EAAE;QACxC,MAAM,uBAAuB,GAAG,aAAa,CAAC,MAAM,CAClD,CAAC,YAAY,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,KAAK,YAAY,CAAC,WAAW,CACjE,CAAA;QACD,IAAI,uBAAuB,CAAC,MAAM,KAAK,CAAC;YAAE,SAAQ;QAClD,4CAA4C;QAC5C,MAAM,QAAQ,GAAG,MAAM,wBAAwB,CAAC,YAAY,EAAE,uBAAuB,EAAE,aAAa,CAAC,CAAA;QACrG,IAAI,CAAC,QAAQ;YAAE,SAAQ;QAEvB,WAAW,CAAC,YAAY,CAAC,eAAe,CAAC,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAA;QACnE,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,KAAK,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAA;QACnG,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,eAAe,KAAK,YAAY,CAAC,eAAe,CAAC,CAAA;KACtG;IAED,OAAO;QACL,WAAW;QACX,QAAQ,EAAE,YAAY;QACtB,UAAU,EAAE,aAAa;KAC1B,CAAA;AACH,CAAC","sourcesContent":["import {selectRemoteSourcePrompt} from './prompts.js'\nimport {LocalSource, RemoteSource} from './identifiers.js'\nimport {IdentifiersExtensions} from '../../models/app/identifiers.js'\n\nexport interface ManualMatchResult {\n  identifiers: IdentifiersExtensions\n  toCreate: LocalSource[]\n  onlyRemote: RemoteSource[]\n}\n\n/**\n * Prompt the user to manually match each of the local sources to a remote source.\n * Sources can either be extensions or functions.\n *\n * The user can also select to create a new remote source instead of selecting an existing one.\n * Manual matching will only show sources of the same type as possible matches.\n * At the end of this process, all remote sources must be matched with the local sources to succeed.\n *\n * @param local - The local sources to match\n * @param remote - The remote sources to match\n * @returns The result of the manual matching\n */\nexport async function manualMatchIds(\n  options: {\n    local: LocalSource[]\n    remote: RemoteSource[]\n  },\n  remoteIdField: 'id' | 'uuid',\n): Promise<ManualMatchResult> {\n  const identifiers: {[key: string]: string} = {}\n  let pendingRemote = options.remote\n  let pendingLocal = options.local\n\n  for (const currentLocal of options.local) {\n    const remoteSourcesOfSameType = pendingRemote.filter(\n      (remoteSource) => remoteSource.type === currentLocal.graphQLType,\n    )\n    if (remoteSourcesOfSameType.length === 0) continue\n    // eslint-disable-next-line no-await-in-loop\n    const selected = await selectRemoteSourcePrompt(currentLocal, remoteSourcesOfSameType, remoteIdField)\n    if (!selected) continue\n\n    identifiers[currentLocal.localIdentifier] = selected[remoteIdField]\n    pendingRemote = pendingRemote.filter((remote) => remote[remoteIdField] !== selected[remoteIdField])\n    pendingLocal = pendingLocal.filter((local) => local.localIdentifier !== currentLocal.localIdentifier)\n  }\n\n  return {\n    identifiers,\n    toCreate: pendingLocal,\n    onlyRemote: pendingRemote,\n  }\n}\n"]}