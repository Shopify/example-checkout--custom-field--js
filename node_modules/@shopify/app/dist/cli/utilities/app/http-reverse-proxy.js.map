{"version":3,"file":"http-reverse-proxy.js","sourceRoot":"","sources":["../../../../src/cli/utilities/app/http-reverse-proxy.ts"],"names":[],"mappings":"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","sourcesContent":["import {renderConcurrent, RenderConcurrentOptions} from '@shopify/cli-kit/node/ui'\nimport {getAvailableTCPPort} from '@shopify/cli-kit/node/tcp'\nimport {AbortController, AbortSignal} from '@shopify/cli-kit/node/abort'\nimport {OutputProcess, outputDebug, outputContent, outputToken, outputWarn} from '@shopify/cli-kit/node/output'\nimport {openURL} from '@shopify/cli-kit/node/system'\nimport {Writable} from 'stream'\nimport * as http from 'http'\n\nexport interface ReverseHTTPProxyTarget {\n  /** The prefix to include in the logs\n   *   [vite] Output coming from Vite\n   */\n  logPrefix: string\n\n  /**\n   * The port to use for the target HTTP server. When undefined, a random port is automatically assigned.\n   */\n  customPort?: number\n\n  /**\n   * The HTTP path prefix used to match against request and determine if the traffic should be\n   * forwarded to this target\n   */\n  pathPrefix?: string\n  /**\n   * A callback to invoke the process. stdout and stderr should be used\n   * to send standard output and error data that gets formatted with the\n   * right prefix.\n   */\n  action: (stdout: Writable, stderr: Writable, signal: AbortSignal, port: number) => Promise<void> | void\n}\n\ninterface Options {\n  previewUrl: string | undefined\n  portNumber: number\n  proxyTargets: ReverseHTTPProxyTarget[]\n  additionalProcesses: OutputProcess[]\n}\n\n/**\n * A convenient function that runs an HTTP server and does path-based traffic forwarding to sub-processes that run\n * an HTTP server. The method assigns a random port to each of the processes.\n * @param tunnelUrl - The URL of the tunnel.\n * @param portNumber - The port to use for the proxy HTTP server. When undefined, a random port is automatically assigned.\n * @param proxyTargets - List of target processes to forward traffic to.\n * @param additionalProcesses - Additional processes to run. The proxy won't forward traffic to these processes.\n * @returns A promise that resolves with an interface to get the port of the proxy and stop it.\n */\nexport async function runConcurrentHTTPProcessesAndPathForwardTraffic({\n  previewUrl,\n  portNumber,\n  proxyTargets,\n  additionalProcesses,\n}: Options): Promise<void> {\n  // Lazy-importing it because it's CJS and we don't want it\n  // to block the loading of the ESM module graph.\n  const {default: httpProxy} = await import('http-proxy')\n\n  const rules: {[key: string]: string} = {}\n\n  const processes = await Promise.all(\n    proxyTargets.map(async (target): Promise<OutputProcess> => {\n      const targetPort = target.customPort || (await getAvailableTCPPort())\n      rules[target.pathPrefix ?? 'default'] = `http://localhost:${targetPort}`\n      return {\n        prefix: target.logPrefix,\n        action: async (stdout, stderr, signal) => {\n          await target.action(stdout, stderr, signal, targetPort)\n        },\n      }\n    }),\n  )\n\n  outputDebug(outputContent`\nStarting reverse HTTP proxy on port ${outputToken.raw(portNumber.toString())}\nRouting traffic rules:\n${outputToken.json(JSON.stringify(rules))}\n`)\n\n  const proxy = httpProxy.createProxy()\n  const server = http.createServer(function (req, res) {\n    const target = match(rules, req)\n    if (target) {\n      return proxy.web(req, res, {target}, (err) => {\n        outputWarn(`Error forwarding web request: ${err}`)\n      })\n    }\n\n    outputDebug(`\nReverse HTTP proxy error - Invalid path: ${req.url}\nThese are the allowed paths:\n${outputToken.json(JSON.stringify(rules))}\n`)\n\n    res.statusCode = 500\n    res.end(`Invalid path ${req.url}`)\n  })\n\n  // Capture websocket requests and forward them to the proxy\n  server.on('upgrade', function (req, socket, head) {\n    const target = match(rules, req)\n    if (target) {\n      return proxy.ws(req, socket, head, {target}, (err) => {\n        outputWarn(`Error forwarding websocket request: ${err}`)\n      })\n    }\n    socket.destroy()\n  })\n\n  const abortController = new AbortController()\n  abortController.signal.addEventListener('abort', () => {\n    server.close()\n  })\n\n  let renderConcurrentOptions: RenderConcurrentOptions = {\n    processes: [...processes, ...additionalProcesses],\n    abortController,\n  }\n\n  if (previewUrl) {\n    renderConcurrentOptions = {\n      ...renderConcurrentOptions,\n      onInput: (input, _key, exit) => {\n        if (input === 'p' && previewUrl) {\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          openURL(previewUrl)\n        } else if (input === 'q') {\n          exit()\n        }\n      },\n      footer: {\n        shortcuts: [\n          {\n            key: 'p',\n            action: 'open your browser',\n          },\n          {\n            key: 'q',\n            action: 'quit',\n          },\n        ],\n        subTitle: `Preview URL: ${previewUrl}`,\n      },\n    }\n  }\n\n  await Promise.all([renderConcurrent(renderConcurrentOptions), server.listen(portNumber)])\n}\n\nfunction match(rules: {[key: string]: string}, req: http.IncomingMessage) {\n  const path: string = req.url ?? '/'\n\n  for (const pathPrefix in rules) {\n    if (path.startsWith(pathPrefix)) return rules[pathPrefix]\n  }\n\n  return rules.default\n}\n"]}